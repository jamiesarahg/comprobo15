What was the goal of your project?
	The robot's odometry coordinate system is extremely useful, but it is an open feedback loop. Therefore, when the robot is moving for a long time or bumps into obstacles, its perception of where it is in the odom plane becomes more and more incorrect. We set out to build a particle filter that, given a map of a space and a reasonable guess of the robot's location, could close the feedback loop and more accurately determine the location of the robot over long periods of time or when obstacles were involved. 

How did you solve the problem? (Note: this doesn't have to be super-detailed, you should try to explain what you did at a high-level so that others in the class could reasonably understand what you did).
	Given a map of the space and a good guess for the robot's initial odometry location, we generated a particle cloud that contained 300 (a number chosen somewhat arbitrarily) guesses for where the robot could be, including its position and orientation. The cloud was generated by taking the initial guess and adding some randomly generated noise for each particle. Every time the robot moved in the odometry coordinates, the center of the particle cloud would also move. In addition, every time the lidar published new scan data, each particle was given a weight that represented the likelihood that in a Gaussian distribution it perfectly represented the robot's coordinates given the lidar data. Once every particle's weight was updated, a random Gaussian distribution was sampled based on the particle weights. This meant that particles with higher weights would appear in this sample several times, while particles with low weights would appear fewer times or not at all. Each particle was then updated to include noise again, and the process was repeated. Eventually, the particles converged on the robot's actual position. 
Describe a design decision you had to make when working on your project and what you ultimately did (and why)? These design decisions could be particular choices for how you implemented some part of an algorithm or perhaps a decision regarding which of two external packages to use in your project.
	One of our key design decisions was how to update our estimate of the robot's position as new data was collected. We chose between taking a weighted average of all of the particle estimates or simply choosing the single particle with the highest weight. We ultimately decided to base the outcome on a single particle because we were worried about bifurcations in our estimates. For example, a robot in one corner would see similar readings as a robot in the opposite corner. Consider the case where particles are clustered around two centers in opposite corners and have similar probabilities. With the averaging method, the estimate for the robot's position would be in the center of the room, which is not a very reasonable guess. Therefore, we thought it would be better to choose one cluster in a bifurcation rather than get caught between two. 
What if any challenges did you face along the way?
	We had trouble dealing with angles again. The positive versus negative angles has proven to be hard on us. We also found it challening to convert the work that we had done in simulation to the actual robots. 
What would you do to improve your project if you had more time?
	If I had more time, I would want to try to build another map in a more conducive space and see how the particle filter worked there. We also decided to determine the robot position based on the most likely particle. While we made this design decision because we thought it was the best strategy, I would have like to see how it would have worked if we did a weighted average of the particle locations based on the likelihood to see how this strategy compared to the one we used. 
Did you learn any interesting lessons for future robotic programming projects? These could relate to working on robotics projects in teams, working on more open-ended (and longer term) problems, or any other relevant topic.
	In the last two projects, we have learned a lot about the best practices for pair programming. We first tried completely splitting up tasks. We then tried entirely co-programming. This time, we did a combination of pair programming and and using version conrol to simultaneously work on seperate functions. We also completed the lab entirely in the simulator before testing it on the robot, which allowed us to easily test and correct each piece of code as it was updated. The combination helped us parellelize much more and work more efficiently than we had in either of the previous labs. 
